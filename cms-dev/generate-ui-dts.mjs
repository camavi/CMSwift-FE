import fs from "node:fs/promises";
import fsSync from "node:fs";
import path from "node:path";

const CWD = process.cwd();
const OUTPUT_PATH = path.join(CWD, "types", "cmswift-ui.d.ts");
const HEADER = "// AUTO-GENERATED - DO NOT EDIT.\n";
const ICONS_INFO_PATH = path.join(CWD, "cms-dev", "tabler-icons", "tabler-icons-info.json");
const DOM_ELEMENTS_PATH = path.join(CWD, "cms-dev", "dom", "elements.json");

// Parsing strategy: regex for declarations + lightweight scanners for params/body.
// This is intentionally fast and conservative, not a full JS parser.
const args = process.argv.slice(2);
const watchMode = args.includes("--watch");
const rootArgs = args.filter((arg) => arg !== "--watch");

const defaultRootCandidates = [
  "src",
  "_cmswift",
  "pages/_cmswift-fe/js",
];

const roots = resolveRoots(rootArgs.length ? rootArgs : defaultRootCandidates);

const IGNORED_DIRS = new Set([
  "node_modules",
  ".git",
  "dist",
  "build",
  "coverage",
  ".cache",
  ".turbo"
]);

const SOURCE_EXTS = new Set([".js", ".mjs", ".cjs"]);

await generateOnce();

if (watchMode) {
  startWatch(roots, generateOnce);
}

function resolveRoots(candidates) {
  const existing = [];
  for (const entry of candidates) {
    const abs = path.resolve(CWD, entry);
    if (fsSync.existsSync(abs) && fsSync.statSync(abs).isDirectory()) {
      existing.push(abs);
    }
  }
  if (!existing.length) {
    existing.push(CWD);
  }
  return [...new Set(existing)];
}

async function generateOnce() {
  const files = await collectSourceFiles(roots);
  const iconIds = await loadTablerIconIds();
  const domElements = await loadDomElements();
  const uiComponents = new Map();
  const cmswiftComponents = new Map();
  const cmswiftUiComponents = new Map();
  const cmswiftHttpComponents = new Map();

  for (const filePath of files) {
    const content = await fs.readFile(filePath, "utf8");
    const uiParsed = extractUiComponentsFromSource(content, filePath);
    const cmswiftParsed = extractCmswiftComponentsFromSource(content, filePath);
    const cmswiftUiParsed = extractCmswiftUiComponentsFromSource(content, filePath);
    const cmswiftHttpParsed = extractCmswiftHttpComponentsFromSource(content, filePath);

    mergeComponents(uiComponents, uiParsed);
    mergeComponents(cmswiftComponents, cmswiftParsed);
    mergeComponents(cmswiftUiComponents, cmswiftUiParsed);
    mergeComponents(cmswiftHttpComponents, cmswiftHttpParsed);
  }

  mergeComponents(cmswiftUiComponents, [...uiComponents.values()]);

  const uiNames = [...uiComponents.keys()].sort((a, b) => a.localeCompare(b));
  const cmswiftNames = [...cmswiftComponents.keys()].sort((a, b) => a.localeCompare(b));
  const cmswiftUiNames = [...cmswiftUiComponents.keys()].sort((a, b) => a.localeCompare(b));
  const cmswiftHttpNames = [...cmswiftHttpComponents.keys()].sort((a, b) => a.localeCompare(b));
  const lines = [];
  lines.push(HEADER.trimEnd());
  lines.push("// Generated by tools/generate-ui-dts.mjs");
  lines.push("");
  lines.push("export {};");
  lines.push("");
  lines.push("declare global {");
  lines.push("  namespace UI {");
  if (iconIds.length) {
    emitIconTypes(lines, iconIds, 4);
    lines.push("");
  }

  for (const name of uiNames) {
    const info = uiComponents.get(name);
    if (info.jsdoc) {
      lines.push(...indentBlock(info.jsdoc, 4));
    }
    if (name === "Icon" && iconIds.length) {
      emitIconFunctionDeclarations(lines, info, 4);
    } else if (name === "Btn" && iconIds.length) {
      emitBtnFunctionDeclarations(lines, info, 4);
    } else {
      emitFunctionDeclaration(lines, name, info, 4);
    }
    lines.push("");
  }

  if (lines[lines.length - 1] === "") {
    lines.pop();
  }
  lines.push("  }");

  if (cmswiftNames.length || cmswiftUiNames.length || cmswiftHttpNames.length) {
    lines.push("  namespace CMSwift {");

    for (const name of cmswiftNames) {
      const info = cmswiftComponents.get(name);
      if (info.jsdoc) {
        lines.push(...indentBlock(info.jsdoc, 4));
      }
      emitFunctionDeclaration(lines, name, info, 4);
      lines.push("");
    }

    if (lines[lines.length - 1] === "") {
      lines.pop();
    }

    if (cmswiftHttpNames.length) {
      lines.push("");
      lines.push("    namespace http {");
      for (const name of cmswiftHttpNames) {
        const info = cmswiftHttpComponents.get(name);
        if (info.jsdoc) {
          lines.push(...indentBlock(info.jsdoc, 6));
        }
        emitFunctionDeclaration(lines, name, info, 6);
        lines.push("");
      }
      if (lines[lines.length - 1] === "") {
        lines.pop();
      }
      lines.push("    }");
    }

    lines.push("  }");
  }

  if (domElements.length) {
    emitDomHelpers(lines, domElements, 2);
  }

  lines.push("  const cms = CMSwift;");
  lines.push("  const _ui = UI;");
  lines.push("  const _http = CMSwift.http;");
  lines.push("}");
  lines.push("");

  await fs.mkdir(path.dirname(OUTPUT_PATH), { recursive: true });
  await fs.writeFile(OUTPUT_PATH, lines.join("\n"), "utf8");

  const totalComponents = uiNames.length + cmswiftNames.length + cmswiftUiNames.length;
  console.log(`Generated ${totalComponents} components -> ${OUTPUT_PATH}`);
}

async function loadTablerIconIds() {
  try {
    const raw = await fs.readFile(ICONS_INFO_PATH, "utf8");
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed.filter((value) => typeof value === "string" && value);
  } catch {
    return [];
  }
}

function emitIconTypes(lines, iconIds, indent = 4) {
  const pad = " ".repeat(indent);
  lines.push(`${pad}type IconId =`);
  for (const id of iconIds) {
    lines.push(`${pad}  | "${id}"`);
  }
  lines.push(`${pad};`);
  lines.push(`${pad}type IconName = \`#\${IconId}\` | (string & {});`);
  lines.push(`${pad}type IconProps = {`);
  lines.push(`${pad}  name?: IconName | object | Function | any[] | null | undefined;`);
  lines.push(`${pad}  size?: number | string;`);
  lines.push(`${pad}  color?: string;`);
  lines.push(`${pad}  slots?: { default?: any };`);
  lines.push(`${pad}  class?: string;`);
  lines.push(`${pad}  style?: object;`);
  lines.push(`${pad}  [key: string]: any;`);
  lines.push(`${pad}};`);
  lines.push(`${pad}type BtnProps = {`);
  lines.push(`${pad}  icon?: IconName | object | Function | any[] | null | undefined;`);
  lines.push(`${pad}  [key: string]: any;`);
  lines.push(`${pad}};`);
}

function emitIconFunctionDeclarations(lines, info, indent = 4) {
  const pad = " ".repeat(indent);
  lines.push(`${pad}function Icon(name: IconName, props?: IconProps, ...children: any[]): ${info.returnType};`);
  lines.push(`${pad}function Icon(props: IconProps, ...children: any[]): ${info.returnType};`);
  lines.push(`${pad}function Icon(...args: any[]): ${info.returnType};`);
}

function emitBtnFunctionDeclarations(lines, info, indent = 4) {
  const pad = " ".repeat(indent);
  lines.push(`${pad}function Btn(props: BtnProps, ...children: any[]): ${info.returnType};`);
  lines.push(`${pad}function Btn(...args: any[]): ${info.returnType};`);
}

function emitDomHelpers(lines, domElements, indent = 2) {
  const pad = " ".repeat(indent);
  const innerPad = " ".repeat(indent + 2);
  lines.push(`${pad}type DomHElement = HTMLElement | SVGElement | Text;`);
  lines.push(`${pad}type DomHFactory = (...args: any[]) => DomHElement;`);
  lines.push(`${pad}const _h: {`);
  lines.push(`${innerPad}fragment: (...children: any[]) => any[];`);
  lines.push(`${innerPad}dynamic: (renderFn: Function) => DocumentFragment;`);
  for (const tag of domElements) {
    if (typeof tag !== "string" || !tag) continue;
    const key = isValidIdentifier(tag) ? tag : `"${tag}"`;
    lines.push(`${innerPad}${key}: DomHFactory;`);
  }
  lines.push(`${pad}};`);
  lines.push("");
}

async function loadDomElements() {
  try {
    const raw = await fs.readFile(DOM_ELEMENTS_PATH, "utf8");
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    const seen = new Set();
    const out = [];
    for (const value of parsed) {
      if (typeof value !== "string" || !value || seen.has(value)) continue;
      seen.add(value);
      out.push(value);
    }
    return out;
  } catch {
    return [];
  }
}

function shouldReplaceComponent(existing, next) {
  const existingProps = existing.props ? Object.keys(existing.props).length : 0;
  const nextProps = next.props ? Object.keys(next.props).length : 0;
  if (nextProps !== existingProps) {
    return nextProps > existingProps;
  }
  const existingDoc = existing.jsdoc ? existing.jsdoc.length : 0;
  const nextDoc = next.jsdoc ? next.jsdoc.length : 0;
  return nextDoc > existingDoc;
}

function mergeComponents(map, components) {
  for (const component of components) {
    const existing = map.get(component.name);
    if (!existing || shouldReplaceComponent(existing, component)) {
      map.set(component.name, component);
    }
  }
}

async function collectSourceFiles(rootsList) {
  const files = new Set();
  for (const root of rootsList) {
    await walkDir(root, files);
  }
  return [...files];
}

async function walkDir(dir, files) {
  let entries = [];
  try {
    entries = await fs.readdir(dir, { withFileTypes: true });
  } catch {
    return;
  }

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      if (IGNORED_DIRS.has(entry.name)) continue;
      await walkDir(fullPath, files);
      continue;
    }
    if (!entry.isFile()) continue;
    if (SOURCE_EXTS.has(path.extname(entry.name))) {
      files.add(fullPath);
    }
  }
}

function extractUiComponentsFromSource(source, filePath) {
  const components = [];
  // UI.* assignments and exports cover the majority of CMSwift usage.
  components.push(...extractNamespaceAssignments(source, "UI"));
  components.push(...extractExportedFunctions(source));
  components.push(...extractUiObjectLiteral(source));
  return components.map((component) => ({ ...component, filePath }));
}

function extractCmswiftComponentsFromSource(source, filePath) {
  const components = [];
  components.push(...extractNamespaceAssignments(source, "CMSwift", { returnTypeDefault: "any" }));
  return components.map((component) => ({ ...component, filePath }));
}

function extractCmswiftUiComponentsFromSource(source, filePath) {
  const components = [];
  components.push(...extractNamespaceAssignments(source, "CMSwift.ui"));
  return components.map((component) => ({ ...component, filePath }));
}

function extractCmswiftHttpComponentsFromSource(source, filePath) {
  const components = [];
  components.push(...extractNamespaceAssignments(source, "CMSwift.http", { returnTypeDefault: "any" }));
  return components.map((component) => ({ ...component, filePath }));
}
function extractNamespaceAssignments(source, namespace, options = {}) {
  const results = [];
  const escaped = namespace.replace(/\./g, "\\.");
  const regex = new RegExp(`\\b${escaped}\\.([A-Za-z_$][\\w$]*)\\s*=\\s*`, "g");
  let match;
  while ((match = regex.exec(source))) {
    const name = match[1];
    const exprStart = regex.lastIndex;
    const parsed = parseFunctionFromPosition(source, exprStart);
    if (!parsed) continue;
    results.push(buildComponentInfo(name, parsed, source, match.index, options));
  }
  return results;
}

function extractExportedFunctions(source) {
  const results = [];
  const fnRegex = /\bexport\s+function\s+([A-Za-z_$][\w$]*)\s*\(/g;
  let match;
  while ((match = fnRegex.exec(source))) {
    const name = match[1];
    const parenIndex = source.indexOf("(", fnRegex.lastIndex - 1);
    const parsed = parseFunctionDeclaration(source, parenIndex);
    if (!parsed) continue;
    results.push(buildComponentInfo(name, parsed, source, match.index));
  }

  const constRegex = /\bexport\s+(?:const|let|var)\s+([A-Za-z_$][\w$]*)\s*=\s*/g;
  while ((match = constRegex.exec(source))) {
    const name = match[1];
    const exprStart = constRegex.lastIndex;
    const parsed = parseFunctionFromPosition(source, exprStart);
    if (!parsed) continue;
    results.push(buildComponentInfo(name, parsed, source, match.index));
  }
  return results;
}

function extractUiObjectLiteral(source) {
  const results = [];
  const regex = /\bconst\s+UI\s*=\s*\{/g;
  let match;
  while ((match = regex.exec(source))) {
    const blockStart = source.indexOf("{", match.index);
    const block = extractBalancedBlock(source, blockStart, "{", "}");
    if (!block) continue;
    const blockContent = block.content;
    const offset = block.start;

    const propRegex = /(^|,)\s*([A-Za-z_$][\w$]*)\s*:\s*/g;
    let propMatch;
    while ((propMatch = propRegex.exec(blockContent))) {
      const name = propMatch[2];
      const exprStart = offset + propMatch.index + propMatch[0].length;
      const parsed = parseFunctionFromPosition(source, exprStart);
      if (!parsed) continue;
      results.push(buildComponentInfo(name, parsed, source, exprStart));
    }

    const methodRegex = /(^|,)\s*([A-Za-z_$][\w$]*)\s*\(/g;
    let methodMatch;
    while ((methodMatch = methodRegex.exec(blockContent))) {
      const name = methodMatch[2];
      const parenIndex = offset + methodMatch.index + methodMatch[0].length - 1;
      const parsed = parseFunctionDeclaration(source, parenIndex);
      if (!parsed) continue;
      results.push(buildComponentInfo(name, parsed, source, parenIndex));
    }
  }
  return results;
}

function buildComponentInfo(name, parsed, source, startIndex, options = {}) {
  const props = extractPropsFromParams(parsed.paramsText);
  const returnType = inferReturnType(parsed.bodyText, options.returnTypeDefault);
  const jsdoc = extractJsdoc(source, startIndex);
  const paramSummary = summarizeParams(parsed.paramsText);

  return {
    name,
    props,
    returnType,
    jsdoc,
    paramSummary
  };
}

function buildParamSignature(info) {
  if (info.props && Object.keys(info.props).length) {
    return "(props?: Record<string, any>)";
  }

  if (info.paramSummary.kind === "named-props") {
    return "(props?: Record<string, any>)";
  }

  if (info.paramSummary.kind === "none") {
    return "()";
  }

  return "(...args: any[])";
}

function summarizeParams(paramsText) {
  if (!paramsText || !paramsText.trim()) {
    return { kind: "none" };
  }

  const params = splitTopLevel(paramsText, ",");
  const hasMultiple = params.length > 1;
  const first = params[0]?.trim() || "";
  const isRest = first.startsWith("...");
  const isSingle = params.length === 1;
  const nameMatch = /^([A-Za-z_$][\w$]*)\b/.exec(first);
  const name = nameMatch ? nameMatch[1] : null;
  const looksLikeProps = isSingle && name && /^(props|opts|options|config)$/.test(name);

  if (isSingle && !isRest && looksLikeProps) {
    return { kind: "named-props" };
  }

  if (isSingle && !hasMultiple && !isRest) {
    return { kind: "single" };
  }

  return { kind: "rest" };
}

function parseFunctionFromPosition(source, startIndex) {
  let i = skipWhitespaceAndComments(source, startIndex);
  if (i === -1) return null;

  let isAsync = false;
  if (source.startsWith("async", i)) {
    const next = i + 5;
    if (/\s/.test(source[next])) {
      isAsync = true;
      i = skipWhitespaceAndComments(source, next);
    }
  }

  if (source.startsWith("function", i)) {
    const afterFn = skipWhitespaceAndComments(source, i + "function".length);
    if (afterFn === -1) return null;
    let j = afterFn;
    const nameMatch = /^[A-Za-z_$][\w$]*/.exec(source.slice(j));
    if (nameMatch) {
      j += nameMatch[0].length;
    }
    j = skipWhitespaceAndComments(source, j);
    if (source[j] !== "(") return null;
    const params = extractBalancedBlock(source, j, "(", ")");
    if (!params) return null;
    const bodyStart = skipWhitespaceAndComments(source, params.end + 1);
    const body = bodyStart !== -1 && source[bodyStart] === "{"
      ? extractBalancedBlock(source, bodyStart, "{", "}")
      : null;

    return {
      paramsText: params.content,
      bodyText: body ? body.content : "",
      isAsync
    };
  }

  const arrowParams = extractArrowParams(source, i);
  if (!arrowParams) return null;

  const arrowIndex = skipWhitespaceAndComments(source, arrowParams.end + 1);
  if (arrowIndex === -1 || source.slice(arrowIndex, arrowIndex + 2) !== "=>") {
    return null;
  }

  const bodyStart = skipWhitespaceAndComments(source, arrowIndex + 2);
  if (bodyStart === -1) {
    return null;
  }

  let bodyText = "";
  if (source[bodyStart] === "{") {
    const body = extractBalancedBlock(source, bodyStart, "{", "}");
    bodyText = body ? body.content : "";
  } else {
    bodyText = extractArrowExpression(source, bodyStart);
  }

  return {
    paramsText: arrowParams.content,
    bodyText,
    isAsync
  };
}

function parseFunctionDeclaration(source, parenIndex) {
  const params = extractBalancedBlock(source, parenIndex, "(", ")");
  if (!params) return null;
  const bodyStart = skipWhitespaceAndComments(source, params.end + 1);
  if (bodyStart === -1 || source[bodyStart] !== "{") {
    return { paramsText: params.content, bodyText: "" };
  }
  const body = extractBalancedBlock(source, bodyStart, "{", "}");
  return {
    paramsText: params.content,
    bodyText: body ? body.content : ""
  };
}

function extractArrowParams(source, startIndex) {
  let i = skipWhitespaceAndComments(source, startIndex);
  if (i === -1) return null;
  if (source[i] === "(") {
    return extractBalancedBlock(source, i, "(", ")");
  }
  if (source[i] === "{") {
    return extractBalancedBlock(source, i, "{", "}");
  }
  const idMatch = /^[A-Za-z_$][\w$]*/.exec(source.slice(i));
  if (!idMatch) return null;
  return {
    content: idMatch[0],
    start: i,
    end: i + idMatch[0].length - 1
  };
}

function extractBalancedBlock(source, startIndex, openChar, closeChar) {
  let depth = 0;
  let i = startIndex;
  let inString = null;
  let inBlockComment = false;
  let inLineComment = false;

  for (; i < source.length; i++) {
    const char = source[i];
    const next = source[i + 1];

    if (inLineComment) {
      if (char === "\n") inLineComment = false;
      continue;
    }
    if (inBlockComment) {
      if (char === "*" && next === "/") {
        inBlockComment = false;
        i++;
      }
      continue;
    }

    if (inString) {
      if (char === "\\" && next) {
        i++;
        continue;
      }
      if (char === inString) {
        inString = null;
      }
      continue;
    }

    if (char === "/" && next === "/") {
      inLineComment = true;
      i++;
      continue;
    }
    if (char === "/" && next === "*") {
      inBlockComment = true;
      i++;
      continue;
    }
    if (char === "\"" || char === "'" || char === "`") {
      inString = char;
      continue;
    }

    if (char === openChar) {
      depth++;
      if (depth === 1) {
        startIndex = i;
      }
      continue;
    }
    if (char === closeChar) {
      depth--;
      if (depth === 0) {
        const content = source.slice(startIndex + 1, i);
        return { content, start: startIndex, end: i };
      }
      continue;
    }
  }
  return null;
}

function extractArrowExpression(source, startIndex) {
  let depthParen = 0;
  let depthBrace = 0;
  let depthBracket = 0;
  let inString = null;
  let inBlockComment = false;
  let inLineComment = false;
  let i = startIndex;

  for (; i < source.length; i++) {
    const char = source[i];
    const next = source[i + 1];

    if (inLineComment) {
      if (char === "\n") inLineComment = false;
      continue;
    }
    if (inBlockComment) {
      if (char === "*" && next === "/") {
        inBlockComment = false;
        i++;
      }
      continue;
    }

    if (inString) {
      if (char === "\\" && next) {
        i++;
        continue;
      }
      if (char === inString) {
        inString = null;
      }
      continue;
    }

    if (char === "/" && next === "/") {
      inLineComment = true;
      i++;
      continue;
    }
    if (char === "/" && next === "*") {
      inBlockComment = true;
      i++;
      continue;
    }
    if (char === "\"" || char === "'" || char === "`") {
      inString = char;
      continue;
    }

    if (char === "(") depthParen++;
    if (char === ")") depthParen--;
    if (char === "{") depthBrace++;
    if (char === "}") depthBrace--;
    if (char === "[") depthBracket++;
    if (char === "]") depthBracket--;

    if (depthParen === 0 && depthBrace === 0 && depthBracket === 0) {
      if (char === ";" || char === "\n") {
        break;
      }
    }
  }

  return source.slice(startIndex, i).trim();
}

function skipWhitespaceAndComments(source, startIndex) {
  let i = startIndex;
  while (i < source.length) {
    const char = source[i];
    const next = source[i + 1];
    if (/\s/.test(char)) {
      i++;
      continue;
    }
    if (char === "/" && next === "/") {
      i += 2;
      while (i < source.length && source[i] !== "\n") i++;
      continue;
    }
    if (char === "/" && next === "*") {
      i += 2;
      while (i < source.length && !(source[i] === "*" && source[i + 1] === "/")) i++;
      i += 2;
      continue;
    }
    return i;
  }
  return -1;
}

function extractPropsFromParams(paramsText) {
  if (!paramsText) return null;
  // Only reads the first parameter when it's an object destructure.
  const parts = splitTopLevel(paramsText, ",");
  if (!parts.length) return null;
  const firstParam = parts[0].trim();
  const braceIndex = firstParam.indexOf("{");
  if (braceIndex === -1) return null;

  const block = extractBalancedBlock(firstParam, braceIndex, "{", "}");
  if (!block) return null;

  const rawProps = stripComments(block.content);
  const entries = splitTopLevel(rawProps, ",");
  const props = {};

  for (const entry of entries) {
    const parsed = parsePropEntry(entry);
    if (!parsed) continue;
    const type = inferPropType(parsed.key, parsed.defaultValue);
    props[parsed.key] = type;
  }

  return Object.keys(props).length ? props : null;
}

function parsePropEntry(entry) {
  if (!entry) return null;
  let text = entry.trim();
  if (!text) return null;
  if (text.startsWith("...")) return null;
  if (text.startsWith("//") || text.startsWith("/*")) return null;

  text = text.replace(/^\s*\/\/.*$/, "").trim();
  if (!text) return null;

  const colonIndex = findTopLevelChar(text, ":");
  let keyPart = text;
  let defaultValue = null;

  if (colonIndex !== -1) {
    keyPart = text.slice(0, colonIndex).trim();
    const right = text.slice(colonIndex + 1).trim();
    const eqIndex = findTopLevelChar(right, "=");
    if (eqIndex !== -1) {
      defaultValue = right.slice(eqIndex + 1).trim();
    }
  } else {
    const eqIndex = findTopLevelChar(text, "=");
    if (eqIndex !== -1) {
      keyPart = text.slice(0, eqIndex).trim();
      defaultValue = text.slice(eqIndex + 1).trim();
    }
  }

  if (!keyPart || keyPart.startsWith("[")) return null;

  const key = stripQuotes(keyPart);
  if (!key) return null;

  return { key, defaultValue };
}

function stripQuotes(value) {
  if (!value) return value;
  if ((value.startsWith("\"") && value.endsWith("\"")) ||
    (value.startsWith("'") && value.endsWith("'")) ||
    (value.startsWith("`") && value.endsWith("`"))) {
    return value.slice(1, -1);
  }
  return value;
}

function inferPropType(key, defaultValue) {
  if (key === "class" || key === "className") {
    return "string | string[] | null | undefined";
  }

  if (!defaultValue) return "any";
  const value = defaultValue.trim();
  if (!value) return "any";
  if (value === "null" || value === "undefined") return "any";
  if (value === "true" || value === "false") return "boolean";
  if (/^-?\d+(\.\d+)?$/.test(value)) return "number";
  if ((value.startsWith("\"") && value.endsWith("\"")) ||
    (value.startsWith("'") && value.endsWith("'")) ||
    (value.startsWith("`") && value.endsWith("`"))) {
    return "string";
  }
  return "any";
}

function inferReturnType(bodyText, fallback = "HTMLElement | DocumentFragment | any") {
  if (!bodyText) return fallback;

  // Heuristic only: look for DOM helpers vs object-return patterns.
  const hasDom = /\b_h\./.test(bodyText) ||
    /\bdocument\.createElement\b/.test(bodyText) ||
    /\bcreateElement\b/.test(bodyText) ||
    /\bCMSwift\.ui\b/.test(bodyText);

  const hasFragment = /\bcreateDocumentFragment\b/.test(bodyText);
  const hasObjectReturn = /\breturn\s*\{/.test(bodyText);

  if (hasDom && hasObjectReturn) {
    return "HTMLElement | DocumentFragment | any";
  }
  if (hasFragment) {
    return "DocumentFragment";
  }
  if (hasDom) {
    return "HTMLElement";
  }
  if (hasObjectReturn) {
    return "any";
  }
  return fallback;
}

function extractJsdoc(source, startIndex) {
  const before = source.slice(0, startIndex);
  const match = /\/\*\*[\s\S]*?\*\/\s*$/.exec(before);
  if (!match) return null;
  return match[0].trim();
}

function buildPropsType(props) {
  const keys = Object.keys(props).sort((a, b) => a.localeCompare(b));
  const lines = ["{"];
  for (const key of keys) {
    const safeKey = isValidIdentifier(key) ? key : `"${key}"`;
    lines.push(`  ${safeKey}?: ${props[key]};`);
  }
  lines.push("}");
  return lines;
}

function isValidIdentifier(value) {
  return /^[A-Za-z_$][\w$]*$/.test(value);
}

function indentBlock(text, spaces) {
  const pad = " ".repeat(spaces);
  return text.split("\n").map((line) => (line ? pad + line : line));
}

function emitFunctionDeclaration(lines, name, info, indent = 4) {
  const pad = " ".repeat(indent);
  const innerPad = " ".repeat(indent + 2);
  if (info.props && Object.keys(info.props).length) {
    const typeLines = buildPropsType(info.props);
    lines.push(`${pad}function ${name}(props?: ${typeLines[0]}`);
    for (let i = 1; i < typeLines.length; i++) {
      lines.push(`${innerPad}${typeLines[i]}`);
    }
    lines.push(`${pad}): ${info.returnType};`);
    return;
  }

  lines.push(`${pad}function ${name}${buildParamSignature(info)}: ${info.returnType};`);
}

function splitTopLevel(input, delimiter) {
  const parts = [];
  let current = "";
  let depthParen = 0;
  let depthBrace = 0;
  let depthBracket = 0;
  let inString = null;
  let inBlockComment = false;
  let inLineComment = false;

  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const next = input[i + 1];

    if (inLineComment) {
      current += char;
      if (char === "\n") inLineComment = false;
      continue;
    }
    if (inBlockComment) {
      current += char;
      if (char === "*" && next === "/") {
        current += next;
        inBlockComment = false;
        i++;
      }
      continue;
    }

    if (inString) {
      current += char;
      if (char === "\\" && next) {
        current += next;
        i++;
        continue;
      }
      if (char === inString) {
        inString = null;
      }
      continue;
    }

    if (char === "/" && next === "/") {
      inLineComment = true;
      current += char;
      continue;
    }
    if (char === "/" && next === "*") {
      inBlockComment = true;
      current += char;
      continue;
    }

    if (char === "\"" || char === "'" || char === "`") {
      inString = char;
      current += char;
      continue;
    }

    if (char === "(") depthParen++;
    if (char === ")") depthParen--;
    if (char === "{") depthBrace++;
    if (char === "}") depthBrace--;
    if (char === "[") depthBracket++;
    if (char === "]") depthBracket--;

    if (char === delimiter && depthParen === 0 && depthBrace === 0 && depthBracket === 0) {
      parts.push(current);
      current = "";
      continue;
    }

    current += char;
  }

  if (current || input.endsWith(delimiter)) {
    parts.push(current);
  }

  return parts;
}

function stripComments(input) {
  let out = "";
  let inString = null;
  let inBlockComment = false;
  let inLineComment = false;

  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const next = input[i + 1];

    if (inLineComment) {
      if (char === "\n") {
        inLineComment = false;
        out += char;
      }
      continue;
    }
    if (inBlockComment) {
      if (char === "*" && next === "/") {
        inBlockComment = false;
        i++;
      }
      continue;
    }

    if (inString) {
      out += char;
      if (char === "\\" && next) {
        out += next;
        i++;
        continue;
      }
      if (char === inString) {
        inString = null;
      }
      continue;
    }

    if (char === "/" && next === "/") {
      inLineComment = true;
      i++;
      continue;
    }
    if (char === "/" && next === "*") {
      inBlockComment = true;
      i++;
      continue;
    }
    if (char === "\"" || char === "'" || char === "`") {
      inString = char;
    }
    out += char;
  }

  return out;
}

function findTopLevelChar(text, target) {
  let depthParen = 0;
  let depthBrace = 0;
  let depthBracket = 0;
  let inString = null;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const next = text[i + 1];

    if (inString) {
      if (char === "\\" && next) {
        i++;
        continue;
      }
      if (char === inString) inString = null;
      continue;
    }

    if (char === "\"" || char === "'" || char === "`") {
      inString = char;
      continue;
    }

    if (char === "(") depthParen++;
    if (char === ")") depthParen--;
    if (char === "{") depthBrace++;
    if (char === "}") depthBrace--;
    if (char === "[") depthBracket++;
    if (char === "]") depthBracket--;

    if (char === target && depthParen === 0 && depthBrace === 0 && depthBracket === 0) {
      return i;
    }
  }

  return -1;
}

function startWatch(rootsList, onChange) {
  const debounceMs = 200;
  let timer = null;

  const trigger = () => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      onChange().catch((err) => {
        console.error("UI d.ts generation failed:", err);
      });
    }, debounceMs);
  };

  const watchers = [];

  for (const root of rootsList) {
    try {
      const watcher = fsSync.watch(root, { recursive: true }, (event, filename) => {
        if (!filename) {
          trigger();
          return;
        }
        if (isIgnoredPath(filename)) return;
        if (SOURCE_EXTS.has(path.extname(filename))) {
          trigger();
        }
      });
      watchers.push(watcher);
    } catch (err) {
      console.warn(`Watch not supported for ${root}: ${err.message}`);
      watchDirectoriesFallback(root, trigger, watchers);
    }
  }

  const shutdown = () => {
    for (const watcher of watchers) {
      watcher.close();
    }
    process.exit(0);
  };

  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);
}

function watchDirectoriesFallback(root, trigger, watchers) {
  const stack = [root];
  while (stack.length) {
    const dir = stack.pop();
    let entries = [];
    try {
      entries = fsSync.readdirSync(dir, { withFileTypes: true });
    } catch {
      continue;
    }
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        if (IGNORED_DIRS.has(entry.name)) continue;
        stack.push(fullPath);
      }
    }
    try {
      const watcher = fsSync.watch(dir, (event, filename) => {
        if (!filename) return;
        if (isIgnoredPath(filename)) return;
        if (SOURCE_EXTS.has(path.extname(filename))) {
          trigger();
        }
      });
      watchers.push(watcher);
    } catch {
      // Skip directories we cannot watch.
    }
  }
}

function isIgnoredPath(filePath) {
  const parts = filePath.split(path.sep);
  return parts.some((part) => IGNORED_DIRS.has(part));
}
